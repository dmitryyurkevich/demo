import sys
import shutil

from collections import defaultdict, namedtuple
from dataclasses import dataclass
from glob import iglob
from os.path import isfile, relpath
from re import finditer, sub


file_name = "filename"

delimiters = (" ", "\n", "\t")
specials = {"{", "}", ":", "*", "/", "(", ")", "\""}

headers_ignore_list = ("Repeater", "anchors")

MAX_IDENTICAL_OBJECT_NAMES = 100


def is_regular(char):
    return char not in (*delimiters, *specials)


def is_autogenerated(object_name_value):
    if isinstance(object_name_value, str):
        if object_name_value.startswith("_"):
            return True
    return False


def get_qml(file_path):
    if not isfile(file_path):
        raise FileExistsError(file_path)

    with open (file_path, "r") as f:
        return f.read()


def inject_string_into_file(file_path, injection, injection_position):
    with open(file_path, "r+") as f:
        qml = f.read()
        qml = qml[0:injection_position:] + injection + qml[injection_position::]

        f.seek(0)
        f.write(qml)
        f.truncate()


def reject_string_from_file(file_path, rejection):
    with open(file_path, "r+") as f:
        qml = f.read()
        qml = qml.replace(rejection, "")

        f.seek(0)
        f.write(qml)
        f.truncate()


@dataclass
class Literal:
    index: int
    text: str
    pos_from: int
    pos_to: int


@dataclass
class Level:
    hierarchy: tuple
    literals: tuple


    @property
    def inject_position(self):
        return self.literals[1].pos_from


    @property
    def indent(self):
        return "\t"*(len(self.hierarchy) - 1)


    @property
    def is_root_level(self):
        return len(self.hierarchy) == 1


    @property
    def is_function_or_handler(self):
        return any(sublevel.text in specials for sublevel in self.hierarchy)


    @property
    def is_technical_level(self):
        return any(header.text in headers_ignore_list for header in self.hierarchy)


    @property
    def to_process(self):
        if self.is_root_level:
            return False

        if self.is_technical_level:
            return False
        
        if self.is_function_or_handler:
            return False
        
        return True

 
    def get_object_name_value(self):
        for literals in zip(self.literals, self.literals[1::], 
                            self.literals[2::], self.literals[3::], self.literals[4::]):
            if literals[0].text == "objectName":
                if literals[1].text == ":":
                    if literals[2].text == literals[4].text == "\"":
                        return literals[3].text


class QmlFile(object):
    def __init__(self, file_path):
        self.file_path = file_path
        self.qml = get_qml(file_path=self.file_path)
        
        self.char_to_literal = tuple(QmlFile.map_char_to_literal(self.qml))
        self.literal_to_char = tuple(self.map_literal_to_char())

        self.comments = tuple(self.mark_up_comments())
        
        self.nesting_levels = tuple(self.map_literal_to_nesting_level())
        self.nesting_level_to_indent = None


    @staticmethod
    def map_char_to_literal(qml):
        literal_counter = -0.5 if qml[0] in delimiters else 0

        for index, current_char, previous_char in zip(range(1,len(qml)), (qml)[1:], qml):
            yield literal_counter

            if current_char in delimiters:
                if previous_char in delimiters:
                    continue

                if previous_char in specials:
                    literal_counter += 0.5
                    continue

                if is_regular(previous_char):
                    literal_counter += 0.5
                    continue

            if current_char in specials:
                if previous_char in delimiters:
                    literal_counter = int(literal_counter + 0.5)
                    continue

                if previous_char in specials:
                    literal_counter += 1
                    continue
            
                if is_regular(previous_char):
                    literal_counter += 1
                    continue

            if is_regular(current_char):
                if previous_char in delimiters:
                    literal_counter = int(literal_counter + 0.5)
                    continue

                if previous_char in specials:
                    literal_counter += 1
                    continue

                if is_regular(previous_char):
                    continue
        
        yield literal_counter


    def map_literal_to_char(self):
        current_char_index = 0
        current_literal_index = 0

        while True:
            if current_literal_index not in self.char_to_literal:
                break

            while self.char_to_literal[current_char_index] < current_literal_index:
                current_char_index += 1

            pos_from = current_char_index

            while self.char_to_literal[current_char_index] == current_literal_index:
                current_char_index += 1
                
                if current_char_index >= len(self.char_to_literal):
                    break
                
            pos_to = current_char_index
            
            yield Literal(index = current_literal_index, 
                          text=self.qml[pos_from:pos_to], 
                          pos_from=pos_from, pos_to=pos_to)
            
            current_literal_index += 1


    def mark_up_comments(self):
        yield from self.mark_up_singleline_comments()
        yield from self.mark_up_multiline_comments()


    def mark_up_singleline_comments(self):
        r_e = "(\/\*[\w\'\s\r\n\*]*\*\/)|(\/\/[\w\s\']*)|(\<![\-\-\s\w\>\/]*\>)"
        for c in finditer(r_e, self.qml):
            yield from range(self.char_to_literal[c.start()], int(self.char_to_literal[c.end()-1]))


    def mark_up_multiline_comments(self):
        r_e = "(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/)"
        for c in finditer(r_e, self.qml):
            yield from range(self.char_to_literal[c.start()], int(self.char_to_literal[c.end()]) +1)


    def map_literal_to_nesting_level(self):
        levels = defaultdict(list)        
        hierarchy = [0]

        for current_literal in self.literal_to_char:
            if current_literal.text == "{":
                hierarchy.append(current_literal.index - 1)
                
            if current_literal.text == "}":
                hierarchy.pop()

            levels[tuple(hierarchy)].append(current_literal.index)

        for k, v in levels.items():
            hierarchy = tuple(self.literal_to_char[i] for i in k)
            literals = tuple(self.literal_to_char[i] for i in v if i not in self.comments)
            nested_level = Level(hierarchy=hierarchy, literals=literals)

            if nested_level.to_process:
                yield nested_level


class QtProject(object):
    def __init__(self, folder_path):
        self.folder_path = folder_path

        self.predefined_object_names = tuple(self.iterate_predefined_object_names())
        self.generated_object_names = []

    
    def iterate_qml_files(self):
        for file_path in iglob(self.folder_path + '**/*.qml', recursive=True):
            yield file_path


    def iterate_object_names(self):
        for file_path in self.iterate_qml_files():
            qt_file = QmlFile(file_path)
            for nesting_level in qt_file.nesting_levels:
                yield file_path, nesting_level, nesting_level.get_object_name_value()


    def iterate_predefined_object_names(self):
        for file_path, nesting_level, object_name_value in self.iterate_object_names():
            if object_name_value:
                yield object_name_value


    def get_qml_object_name(self, file_path, nesting_level):
        rel_file_path = relpath(file_path, start=self.folder_path)
        file_prefix = rel_file_path.translate(str.maketrans({"/": "_", "\\": "_", ".": ""}))

        level_prefix = "_".join(sub(r"\W+", "", literal.text) for literal in nesting_level.hierarchy[1::])

        object_name = f"_{file_prefix}__{level_prefix}"

        if not object_name in (*self.generated_object_names, *self.predefined_object_names):
            self.generated_object_names.append(object_name)
            return object_name

        # not to use an infinite loop
        for i in range(MAX_IDENTICAL_OBJECT_NAMES):
            indexed_object_name = f"{object_name}_{i+1}"
            if not indexed_object_name in (*self.generated_object_names, *self.predefined_object_names):
                self.generated_object_names.append(indexed_object_name)
                return indexed_object_name
        else:
            raise RuntimeError("there is too much qml objects with the same object name in the project")


    def list_predefined_object_names(self):
        for object_name in self.predefined_object_names:
            print(object_name)


    def list_missing_object_names(self):
        self.generated_object_names = []
        for file_path, nesting_level, object_name_value in self.iterate_object_names():
            if object_name_value is None:
                print(f"missing {self.get_qml_object_name(file_path=file_path, nesting_level=nesting_level)}")


    def add_missing_object_names(self):
        self.generated_object_names = []
        indentations = defaultdict(list)  

        for file_path, nesting_level, object_name_value in self.iterate_object_names():
            if object_name_value is None:
                indentations[file_path]
                new_object_name_value = self.get_qml_object_name(file_path=file_path, nesting_level=nesting_level)
                
                injection = f"objectName: \"{new_object_name_value}\"\n{nesting_level.indent}"
                inject_position = nesting_level.inject_position + sum(indentations[file_path])

                inject_string_into_file(file_path=file_path, injection=injection, injection_position=inject_position)
                indentations[file_path].append(len(injection))
                
                print(f"add {new_object_name_value}")

    
    def remove_autogenerated_object_names(self):
        for file_path, nesting_level, object_name_value in self.iterate_object_names():
            if is_autogenerated(object_name_value=object_name_value):
                rejection = f"objectName: \"{object_name_value}\"\n{nesting_level.indent}"
                reject_string_from_file(file_path=file_path, rejection=rejection)

                print(f"remove {object_name_value}")


if __name__ == "__main__":
    args = sys.argv[1:]
    if len(args) == 1:
        action = args[0]

        qtp = QtProject(folder_path="./")

        if action == "--inspect":
            qtp.list_predefined_object_names()
            qtp.list_missing_object_names()
            sys.exit(0)

        if action == "--add":
            qtp.add_missing_object_names()
            sys.exit(0)

        if action == "--remove":
            qtp.remove_autogenerated_object_names()
            sys.exit(0)

    print("usage: nominator.py --inspect or --add or --remove")        



